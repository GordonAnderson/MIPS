//
// ARB
//
// This file supports the ARB module for the MIPS system. The MIPS controller
// supports up to two ARB modules.
//
// July 31, 2016
//  Added a second mode traditional ARM mode of operation. With this mode you can
//  define channel output level / pulses. This mode supports rev 2.0 of the ARB
//  and adds the aux output channel as well as offset output.c
//
// October 22, 2016
//  - Add support for two ARB modules
//  - Update the host commands to support module number
//  - Add host commands
//    - Direction
//    - Arb waveform
//  - Added TWI aquire and release around all functions
//  - Added external direction input
//  - Made sure sync supports both channels
//  - ARB module firmware updated
//    - Add save and restore
//    - Add calibration
//    - Fix enable bug waveform
//    - Add new functions
//      * Sync enable / disable (done)
//  - Added compression logic
//    - This will require external clock logic, add flag to indicate external clock.
//      Need to also send command to ARB module as to the frequency so it can mode
//      change as needed. External clock is generated by MIPS controller and provided
//      to ARB module.
//
// This module driver needs to be updated to support 4 total channels. This requires the 
// following updates:
//  - Use a array of pointers to ARB structures and allocate at init time.
//  - Allocate compresser table space at run time
//  - Redesign module selection for 4 boards. Module has only one bit for board
//    select so EEPROM address has to change for second pair. The moudule has only
//    one device address, the ARB DUE. This is a TWI address and programmed different
//    for second pair.
//  - At board init time if channels 1 and 2 are already present then the next two
//    ARB board inits are channels 3 and 4 at secondary TWI addresses. Update the
//    ARB DUE address during init
//  - Make sure ARB DUE is present and responds to proper address
//  - If we have more than 1 ARB module then the module index is the struct array 
//    index
//  - Must init the primary channels first so primary EEPROM addresses must be lower 
//    than secondary pair
//  - Board address becomes module number - 1, and with LSB to select board and use as
//    is for array index, the array index fetches the DUE TWI address
//
// Gordon Anderson
//
#include "ARB.h"
#include "Variants.h"
#include "Hardware.h"
#include "Errors.h"

//MIPS Threads
Thread ARBthread  = Thread();

MIPStimer *ARBclock;

#define ARB ARBarray[SelectedARBboard]

float ARBversion=0;

ARBdata  *ARBarray[4]  = {NULL,NULL,NULL,NULL};
ARBstate *ARBstates[4] = {NULL,NULL,NULL,NULL};
ARBdata  arb;   // This is the display / UI data structure

DIhandler *ARBsweepTrigDI[4];
DIhandler *ARBsyncIN[4];
void (*ARBsweepISRs[4])(void) = {ARB_1_SWEEP_ISR, ARB_2_SWEEP_ISR, ARB_3_SWEEP_ISR, ARB_3_SWEEP_ISR};
DIhandler *DIdirARB[4];
void (*ARBdirISRs[4])(void) = {ARB_1_DIR_ISR, ARB_2_DIR_ISR, ARB_3_DIR_ISR, ARB_4_DIR_ISR};

int   ARBmodule            = 1;
int   ARBselectModule      = 1;
int   NumberOfARBchannels  = 0;
int   SelectedARBboard     = 0;    // Active board, 0 or 1 = A or B
int   CurrentModule        = -1;

// Array used to edit the ARB waveform
int ARBwaveform[32];

// Variables used for ARB channel editing
int   ARBchan      = 1;
float ChanLevel    = 0;
float ChanLevelAll = 0;
int   startI       = 1;
int   stopI        = 10;

char *ARBwfrmList = "SIN,RAMP,TRI,PULSE,ARB";
char WFT[8] = "SIN";

char *ARBmodeList = "TWAVE,ARB";

extern DialogBoxEntry ARBentriesPage2[];
extern DialogBoxEntry ARBwaveformEdit[];
extern DialogBoxEntry ARBentriesRange[];
extern DialogBoxEntry ARBentriesSetup[];
extern DialogBoxEntry ARBentriesSweep[];

// TWAVE mode main menu
DialogBoxEntry ARBentriesPage1[] = {
  {" Module"             , 0, 1, D_INT  , 1, 1  , 1, 21, false, "%2d", &ARBselectModule, NULL, ARBmoduleSelected},
  {" Mode"               , 0, 2, D_LIST,  0, 0  , 7, 16, false, ARBmodeList, arb.Mode, NULL, ModeSelected},
  {" Enable"             , 0, 3, D_ONOFF, 0, 1  , 1, 20, false, NULL, &arb.Enable, NULL, NULL},
  {" Frequency"          , 0, 4, D_INT  , 100, 40000, 100, 16, false, "%7d", &arb.Frequency, NULL, NULL},
  {" Amplitude, Vp-p"    , 0, 5, D_FLOAT, 0, 100, 1, 18, false, "%5.1f", &arb.Voltage, NULL, NULL},
  {" Waveform"           , 0, 6, D_LIST,  0, 0  , 7, 16, false, ARBwfrmList, WFT, NULL, NULL},
  {" Dir"                , 0, 7, D_FWDREV, 0, 1  , 1, 20, false, NULL, &arb.Direction, NULL, NULL},
  {" ARB waveform"       , 0, 8, D_PAGE,  0, 0  , 0, 0,  false, NULL, ARBwaveformEdit, Waveform2EditBuffer, NULL},
  {" Next page"          , 0, 9, D_PAGE,  0, 0  , 0, 0,  false, NULL, ARBentriesPage2, NULL, NULL},
  {" Return to main menu", 0,10, D_MENU,  0, 0  , 0, 0,  false, NULL, &MainMenu, NULL, NULL},
  {NULL},
};

// ARB mode main menu
DialogBoxEntry ARBentriesPage1arb[] = {
  {" Module"             , 0, 1, D_INT  , 1, 1  , 1, 21, false, "%2d", &ARBselectModule, NULL, ARBmoduleSelected},
  {" Mode"               , 0, 2, D_LIST,  0, 0  , 7, 16, false, ARBmodeList, arb.Mode, NULL, ModeSelected},
  {" Enable"             , 0, 3, D_ONOFF, 0, 1  , 1, 20, false, NULL, &arb.Enable, NULL, NULL},
  {" Frequency"          , 0, 4, D_INT  , 100, 1000000, 1000, 16, false, "%7d", &arb.Frequency, NULL, NULL},
  {" Amplitude, Vp-p"    , 0, 5, D_FLOAT, 0, 100, 1, 18, false, "%5.1f", &arb.Voltage, NULL, NULL},
  {" Buf length"         , 0, 6, D_INT  , 100, 8000, 10, 17, false, "%6d", &arb.BufferLength, NULL, NULL},
  {" Num buf"            , 0, 7, D_INT  , 0, 1000000, 1, 17, false, "%6d", &arb.NumBuffers, NULL, NULL},
  {" Set all channels"   , 0, 8, D_FLOAT, -100, 100, .1, 17, false, "%6.1f", &ChanLevelAll, NULL, SetChans},
  {" Set chan range"     , 0, 9, D_PAGE , 0, 0  , 0, 0,  false, NULL, ARBentriesRange, NULL, NULL},
  {" Next page"          , 0,10, D_PAGE,  0, 0  , 0, 0,  false, NULL, ARBentriesPage2, NULL, NULL},
  {" Return to main menu", 0,11, D_MENU,  0, 0  , 0, 0,  false, NULL, &MainMenu, NULL, NULL},
  {NULL},
};

DialogBoxEntry ARBentriesRange[] = {
  {" Set channel"        , 0, 1, D_INT   , 1, 8, 1, 21, false, "%2d", &ARBchan, NULL, NULL},
  {" Set start index"    , 0, 2, D_INT   , 1, 8000, 1, 17, false, "%6d", &startI, NULL, NULL},
  {" Set stop index"     , 0, 3, D_INT   , 1, 8000, 1, 17, false, "%6d", &stopI, NULL, NULL},
  {" Set chan level"     , 0, 4, D_FLOAT , -100, 100, .1, 17, false, "%6.1f", &ChanLevel, NULL, NULL},
  {" Set chan range"     , 0, 5, D_FUNCTION , 0, 0  , 0, 0,  false, NULL, NULL, SetChannelRange, NULL},
  {" First page"         , 0, 9, D_PAGE, 0, 0, 0, 0, false, NULL, ARBentriesPage1arb, NULL, NULL},
  {NULL},
};

DialogBoxEntry ARBentriesPage2[] = {
  {" Aux voltage"        , 0, 1, D_FLOAT   , -50, 50, 0.1, 18, false, "%5.1f", &arb.Aux, NULL, NULL},
  {" Offset, Volts"      , 0, 2, D_FLOAT   , -50, 50, 0.1, 18, false, "%5.1f", &arb.Offset, NULL, NULL},
  {" Setup"              , 0, 3, D_PAGE    , 0, 0, 0, 0, false, NULL, ARBentriesSetup, NULL, NULL},
  {" Offset A"           , 0, 4, D_OFF     , -10, 10, 0.1, 18, false, "%5.1f", &arb.OffsetA, NULL, NULL},
  {" Offset B"           , 0, 5, D_OFF     , -10, 10, 0.1, 18, false, "%5.1f", &arb.OffsetB, NULL, NULL},  
  {" Sweep"              , 0, 6, D_OFF     , 0, 0, 0, 0, false, NULL, ARBentriesSweep, NULL, NULL},
  {" Compressor"         , 0, 7, D_OFF     , 0, 0, 0, 0, false, NULL, &ARBCompressorDialog, NULL,NULL},
  {" Ramp rate"          , 0, 8, D_OFF     , 0, 10000, 1, 17, false, "%6.1f", &arb.RampRate, NULL, NULL},
  {" Save settings"      , 0, 9, D_FUNCTION, 0, 0, 0, 0, false, NULL, NULL, SaveARBsettings, NULL},
  {" Restore settings"   , 0,10, D_FUNCTION, 0, 0, 0, 0, false, NULL, NULL, RestorARBsettings, NULL},
  {" First page"         , 0,11, D_PAGE    , 0, 0, 0, 0, false, NULL, ARBentriesPage1, NULL, NULL},
  {NULL},
};

DialogBoxEntry ARBentriesSetup[] = {
  {" Sync input"         , 0, 1, D_DI     , 0, 0, 2, 21, false, DIlist, &arb.ARBsyncIn, NULL, NULL},
  {" Sync level"         , 0, 2, D_DILEVEL, 0, 0, 4, 19, false, DILlist, &arb.ARBsyncLevel, NULL, NULL},
  {" Dir input"          , 0, 3, D_DI     , 0, 0, 2, 21, false, NULL, &arb.ARBdirDI, NULL, NULL},
  {" Dir level"          , 0, 4, D_DILEVEL, 0, 0, 4, 19, false, NULL, &arb.ARBdirLevel, NULL, NULL},
  {" Return"             , 0,10, D_PAGE, 0, 0, 0, 0, false, NULL, ARBentriesPage2, NULL, NULL},
  {NULL},
};

DialogBoxEntry ARBentriesSweep[] = {
  {" Start freq"         , 0, 1, D_INT    , 1000, 40000, 100, 18, false, "%6d", &arb.StartFreq, NULL, NULL},
  {" Stop freq"          , 0, 2, D_INT    , 1000, 40000, 100, 18, false, "%6d", &arb.StopFreq, NULL, NULL},
  {" Start Vp-p"         , 0, 3, D_FLOAT  , -50, 50, 0.1, 19, false, "%5.1f", &arb.StartVoltage, NULL, NULL},
  {" Stop Vp-p"          , 0, 4, D_FLOAT  , -50, 50, 0.1, 19, false, "%5.1f", &arb.StopVoltage, NULL, NULL},
  {" Sweep time, sec"    , 0, 5, D_FLOAT  , 0.1, 1000, 0.1, 18, false, "%6.1f", &arb.SweepTime, NULL, NULL},
  {" Trig input"         , 0, 7, D_DI     , 0, 0, 2, 22, false, DIlist, &arb.ARBsweepTrig, NULL, NULL},
  {" Trig level"         , 0, 8, D_DILEVEL, 0, 0, 4, 20, false, DILlist, &arb.ARBsweepLevel, NULL, NULL},
  {" Return"             , 0,10, D_PAGE   , 0, 0, 0, 0, false, NULL, ARBentriesPage2, NULL, NULL},
  {NULL},
};

DialogBoxEntry ARBwaveformEdit[] = {
  {"Index  values(-100to100)", 0, 1, D_TITLE, 0, 0, 0, false, NULL, NULL, NULL, NULL},
  {"00-03" ,  0, 2, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[0], NULL, NULL},
  {" "     ,  9, 2, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[1], NULL, NULL},
  {" "     , 14, 2, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[2], NULL, NULL},
  {" "     , 19, 2, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[3], NULL, NULL},

  {"04-07" ,  0, 3, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[4], NULL, NULL},
  {" "     ,  9, 3, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[5], NULL, NULL},
  {" "     , 14, 3, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[6], NULL, NULL},
  {" "     , 19, 3, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[7], NULL, NULL},

  {"08-11" ,  0, 4, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[8], NULL, NULL},
  {" "     ,  9, 4, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[9], NULL, NULL},
  {" "     , 14, 4, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[10], NULL, NULL},
  {" "     , 19, 4, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[11], NULL, NULL},

  {"12-15" ,  0, 5, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[12], NULL, NULL},
  {" "     ,  9, 5, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[13], NULL, NULL},
  {" "     , 14, 5, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[14], NULL, NULL},
  {" "     , 19, 5, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[15], NULL, NULL},

  {"16-19" ,  0, 6, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[16], NULL, NULL},
  {" "     ,  9, 6, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[17], NULL, NULL},
  {" "     , 14, 6, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[18], NULL, NULL},
  {" "     , 19, 6, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[19], NULL, NULL},

  {"20-23" ,  0, 7, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[20], NULL, NULL},
  {" "     ,  9, 7, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[21], NULL, NULL},
  {" "     , 14, 7, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[22], NULL, NULL},
  {" "     , 19, 7, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[23], NULL, NULL},

  {"24-27" ,  0, 8, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[24], NULL, NULL},
  {" "     ,  9, 8, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[25], NULL, NULL},
  {" "     , 14, 8, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[26], NULL, NULL},
  {" "     , 19, 8, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[27], NULL, NULL},

  {"28-31" ,  0, 9, D_INT, -100, 100, 1, 5, false, "%4d", &ARBwaveform[28], NULL, NULL},
  {" "     ,  9, 9, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[29], NULL, NULL},
  {" "     , 14, 9, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[30], NULL, NULL},
  {" "     , 19, 9, D_INT, -100, 100, 1, 1, false, "%4d", &ARBwaveform[31], NULL, NULL},

  {" Return to ARB menu", 0, 11, D_PAGE, 0, 0, 0, 0, false, NULL, ARBentriesPage1, EditBuffer2Waveform, NULL},
  {NULL},
};

DialogBox ARBdialog = {
  {
    "ARB control parameters",
    ILI9340_BLACK, ILI9340_WHITE,
    2, 0, 0, 300, 220, B_DOUBLE, 12
  },
  M_SCROLLING, 0, 0,false, ARBentriesPage1
};

MenuEntry MEARBmodule = {" ARB module", M_DIALOG, 0, 0, 0, NULL, &ARBdialog, NULL, NULL};

// This is a pre processing function called my the UI before the screen loads that allows
// the user to edit a waveform. This function sets the number of points per period
void SetupNumWaveformPoints(void)
{
  for(int i=0;i<ppp;i++)
  {
    if(i < arb.PPP) ARBwaveformEdit[i+1].Type = D_INT;
    else ARBwaveformEdit[i+1].Type = D_OFF;
  }
}

// ISRs
void ARB_1_SWEEP_ISR(void)
{
   int b;
  
   // Acquire the TWI resource, if bust then put this function
   // in the queue to run when its freeded
   if((b = ARBmoduleToBoard(1,false)) == -1) return;
   if(AcquireTWI()) 
   {
      int brd = SelectedBoard();
      // Send the start command to the ARB
      SetByte(b, TWI_SWPGO, SS_START);
      SelectBoard(brd);
      return;
   }
   TWIqueue(ARB_1_SWEEP_ISR);
}
void ARB_2_SWEEP_ISR(void)
{
   int b;
  
   // Acquire the TWI resource, if bust then put this function
   // in the queue to run when its freeded
   if((b = ARBmoduleToBoard(2,false)) == -1) return;
   if(AcquireTWI()) 
   {
      int brd = SelectedBoard();
      // Send the start command to the ARB
      SetByte(b, TWI_SWPGO, SS_START);
      SelectBoard(brd);
      return;
   }
   TWIqueue(ARB_2_SWEEP_ISR);
}
void ARB_3_SWEEP_ISR(void)
{
   int b;
  
   // Acquire the TWI resource, if bust then put this function
   // in the queue to run when its freeded
   if((b = ARBmoduleToBoard(3,false)) == -1) return;
   if(AcquireTWI()) 
   {
      int brd = SelectedBoard();
      // Send the start command to the ARB
      SetByte(b, TWI_SWPGO, SS_START);
      SelectBoard(brd);
      return;
   }
   TWIqueue(ARB_3_SWEEP_ISR);
}
void ARB_4_SWEEP_ISR(void)
{
   int b;
  
   // Acquire the TWI resource, if bust then put this function
   // in the queue to run when its freeded
   if((b = ARBmoduleToBoard(4,false)) == -1) return;
   if(AcquireTWI()) 
   {
      int brd = SelectedBoard();
      // Send the start command to the ARB
      SetByte(b, TWI_SWPGO, SS_START);
      SelectBoard(brd);
      return;
   }
   TWIqueue(ARB_4_SWEEP_ISR);
}

void ARB_1_DIR_ISR(void)
{
  if (DIdirARB[0]->activeLevel()) ARBarray[0]->Direction = true;
  else ARBarray[0]->Direction = false;
  if (0 == SelectedARBboard)
  {
    if (DIdirARB[0]->activeLevel()) arb.Direction = true;
    else arb.Direction = false;
  }
  // Need to make ARB loop run, put at top of queue
  ARBthread.setNextRunTime(millis());
}
void ARB_2_DIR_ISR(void)
{
  if (DIdirARB[1]->activeLevel()) ARBarray[1]->Direction = true;
  else ARBarray[1]->Direction = false;
  if (1 == SelectedARBboard)
  {
    if (DIdirARB[1]->activeLevel()) arb.Direction = true;
    else arb.Direction = false;
  }
  // Need to make ARB loop run, put at top of queue
  ARBthread.setNextRunTime(millis());
}
void ARB_3_DIR_ISR(void)
{
  if (DIdirARB[2]->activeLevel()) ARBarray[2]->Direction = true;
  else ARBarray[2]->Direction = false;
  if (2 == SelectedARBboard)
  {
    if (DIdirARB[2]->activeLevel()) arb.Direction = true;
    else arb.Direction = false;
  }
  // Need to make ARB loop run, put at top of queue
  ARBthread.setNextRunTime(millis());
}
void ARB_4_DIR_ISR(void)
{
  if (DIdirARB[3]->activeLevel()) ARBarray[3]->Direction = true;
  else ARBarray[3]->Direction = false;
  if (3 == SelectedARBboard)
  {
    if (DIdirARB[3]->activeLevel()) arb.Direction = true;
    else arb.Direction = false;
  }
  // Need to make ARB loop run, put at top of queue
  ARBthread.setNextRunTime(millis());
}
//

// This function sends the mode command to the ARB module
// defined by board
void SetMode(int board, char *mode)
{
  if(strcmp(mode,"TWAVE") == 0) SetByte(board, TWI_SET_MODE, 0);
  else SetByte(board, TWI_SET_MODE, 1);
}

void ARBmoduleSelected(void)
{
  ARBmodule = ARBselectModule;
}

// This function setups the dialogbox for the selected mode.
void SetModeMenus(bool paint = true)
{
  DialogBoxEntry *de;

  de = GetDialogEntries(ARBentriesPage2, "First page");
  if(strcmp(arb.Mode,"TWAVE") == 0)
  {
    // Define main menu
    ARBdialog.Entry = ARBentriesPage1;
    // Set the return page menu
    de->Value = (void *)ARBentriesPage1;
    ARBdialog.State = M_SCROLLING;
    // If DualOutputs flag is set then enable the Offset menu options, else disable the options
    de = GetDialogEntries(ARBentriesPage2, "Offset A");
    de[0].Type = de[1].Type = D_OFF;
    if(arb.DualOutputs) de[0].Type = de[1].Type = D_FLOAT;
    // Enable the compressor menu only on board 0 (the first channel)
    de = GetDialogEntries(ARBentriesPage2, "Compressor");
    if(de != NULL) de->Type = D_OFF;
    if((de != NULL) && (ARBarray[0]->CompressorEnabled) && (SelectedARBboard == 0)) de->Type = D_DIALOG;    
    // Set the max frequency for this channel and for the sweep options
    de = GetDialogEntries(ARBentriesPage1, "Frequency");
    de->Max = MAXARBRATE / arb.PPP;
    de = GetDialogEntries(ARBentriesSweep, "Start freq");
    de->Max = MAXARBRATE / arb.PPP;
    de = GetDialogEntries(ARBentriesSweep, "Stop Freq");
    de->Max = MAXARBRATE / arb.PPP;
  }
  else
  {
    // Define main menu
    ARBdialog.Entry = ARBentriesPage1arb;
    // Set the return page menu
    de->Value = (void *)ARBentriesPage1arb;
    ARBdialog.State = M_SCROLLING;
  }
  // Repaint main menu
  if(paint) DialogBoxDisplay(&ARBdialog);
}

void ModeSelected(void)
{
  SetModeMenus(true);
}

void SetChans(void)
{
  SetFloat(SelectedARBboard, TWI_SET_SET_BUFFER, ChanLevelAll);
}

// Sets channel range in ARB mode
void SetChannelRange(void)
{
  SetChannelRangeMessage(SelectedARBboard,ARBchan,startI,stopI,ChanLevel);
}

void SetChannelRangeMessage(int board, int channel, int strtI, int stpI, float val)
{
  uint8_t *b;

  SelectBoard(board);
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_SET_CHN_RNG);

  channel--;
  b = (uint8_t *)&channel;
  Wire.write(b[0]);

  b = (uint8_t *)&strtI;
  Wire.write(b[0]);
  Wire.write(b[1]);

  b = (uint8_t *)&stpI;
  Wire.write(b[0]);
  Wire.write(b[1]);

  b = (uint8_t *)&val;
  Wire.write(b[0]);
  Wire.write(b[1]);
  Wire.write(b[2]);
  Wire.write(b[3]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetBufferLength(int board, int BufferLength)
{
  uint8_t *b;

  SelectBoard(board);
  b = (uint8_t *)&BufferLength;
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_BUFFER_LEN);
  Wire.write(b[0]);
  Wire.write(b[1]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetNumBuffers(int board, int NumBuffers)
{
  uint8_t *b;

  SelectBoard(board);
  b = (uint8_t *)&NumBuffers;
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_NUM_BUFFER);
  Wire.write(b[0]);
  Wire.write(b[1]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

// Accepts the waveform type and returns a descriptive string
String GetWaveformString(WaveFormTypes wft)
{
  switch (wft)
  {
    case ARB_SIN:
      return ("SIN");
    case ARB_RAMP:
      return ("RAMP");
    case ARB_TRIANGLE:
      return ("TRI");
    case ARB_PULSE:
      return ("PULSE");
    case ARB_ARB:
      return ("ARB");
    default:
      return ("");
  }
}

// Accepts a waveform type descriptive string and retuns the type
WaveFormTypes GetWaveformType(String WaveformString)
{
  if (WaveformString == String("SIN"))        return (ARB_SIN);
  else if (WaveformString == String("RAMP"))  return (ARB_RAMP);
  else if (WaveformString == String("TRI"))   return (ARB_TRIANGLE);
  else if (WaveformString == String("PULSE")) return (ARB_PULSE);
  else if (WaveformString == String("ARB"))   return (ARB_ARB);
  return(ARB_SIN);
}

// Copies the edit buffer waveform to the modules storage buffer.
// This function also sends the ARB vector to the ARB module.
void EditBuffer2Waveform(void)
{
  int i;

  for (i = 0; i < ppp; i++) ARBarray[SelectedARBboard]->WaveForm[i] = arb.WaveForm[i] = ARBwaveform[i];
  // Set flag to cause ARB waveform update in the processing loop.
  ARBstates[SelectedARBboard]->ARBwaveformUpdate = true;
}

void Waveform2EditBuffer(void)
{
  int i;

  for (i = 0; i < ppp; i++) ARBwaveform[i] = arb.WaveForm[i];
  SetupNumWaveformPoints();
}

// Update the dialog box and display
void SelectARBmodule(bool paint = true)
{
  String wft_string;

//  wft_string = GetWaveformString(ARB->wft);  // Moved these two lines 9/1/17
//  strcpy(WFT, wft_string.c_str());
  if(ARBmodule == 1)
  {
    if(ARBarray[0] != NULL) SelectedARBboard = 0;
    else SelectedARBboard = 1;
  }
  else SelectedARBboard = ARBmodule - 1;
  wft_string = GetWaveformString(ARB->wft);
  strcpy(WFT, wft_string.c_str());
  SelectBoard(SelectedARBboard);
  arb = *ARB;
  SetModeMenus(paint);
}

bool ReadFloat(int board,int cmd, float *value)
{
  byte *b;
  int  i=0;

  b = (byte *)value;
  SelectBoard(board);
  AcquireTWI();
  AtomicBlock< Atomic_RestoreState > a_Block;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  if(Wire.endTransmission() !=0) {ReleaseTWI(); return false;}
  Wire.requestFrom((uint8_t)ARBarray[board]->ARBadr, (uint8_t)4);
  while (Wire.available()) b[i++] = Wire.read();
  ReleaseTWI();
  if(fpclassify(*value) != FP_NORMAL)
  {
    *value = 0;
    return false;
  }
  if(i==4) return true;
  return false;
}

bool Read32bitInt(int board,int cmd, int *value)
{
  byte *b;
  int  i=0;

  b = (byte *)value;
  SelectBoard(board);
  AcquireTWI();
  AtomicBlock< Atomic_RestoreState > a_Block;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  if(Wire.endTransmission() !=0) {ReleaseTWI(); return false;}
  Wire.requestFrom((uint8_t)ARBarray[board]->ARBadr, (uint8_t)4);
  while (Wire.available()) b[i++] = Wire.read();
  ReleaseTWI();
  if(i==4) return true;
  return false;
}

bool Read24bitUnsigned(int board,int cmd, int *value)
{
  byte *b;
  int  i=0;

  b = (byte *)value;
  SelectBoard(board);
  AcquireTWI();
  AtomicBlock< Atomic_RestoreState > a_Block;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  if(Wire.endTransmission() !=0) {ReleaseTWI(); return false;}
  Wire.requestFrom((uint8_t)ARBarray[board]->ARBadr, (uint8_t)3);
  while (Wire.available()) b[i++] = Wire.read();
  ReleaseTWI();
  if(i==3) return true;
  return false;
}

bool Read16bitUnsigned(int board,int cmd, int *value)
{
  byte *b;
  int  i=0;

  b = (byte *)value;
  SelectBoard(board);
  AcquireTWI();
  AtomicBlock< Atomic_RestoreState > a_Block;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  if(Wire.endTransmission() !=0) {ReleaseTWI(); return false;}
  Wire.requestFrom((uint8_t)ARBarray[board]->ARBadr, (uint8_t)2);
  while (Wire.available()) b[i++] = Wire.read();
  ReleaseTWI();
  if(i==2) return true;
  return false;
}

bool Read8bitUnsigned(int board,int cmd, int *value)
{
  byte *b;
  int  i=0;

  b = (byte *)value;
  SelectBoard(board);
  AcquireTWI();
  AtomicBlock< Atomic_RestoreState > a_Block;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  if(Wire.endTransmission() !=0) {ReleaseTWI(); return false;}
  Wire.requestFrom((uint8_t)ARBarray[board]->ARBadr, (uint8_t)1);
  while (Wire.available()) b[i++] = Wire.read();
  ReleaseTWI();
  if(i==1) return true;
  return false;
}

void SetBool(int board, int cmd, bool flag)
{
  SelectBoard(board);
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(flag);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetByte(int board, int cmd, byte bval)
{
  SelectBoard(board);
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(bval);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetWord(int board, int cmd, uint16_t wval)
{
  SelectBoard(board);
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(wval & 0xFF);
  Wire.write((wval >> 8) & 0xFF);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void Set16bitInt(int board, int cmd, int ival)
{
  SelectBoard(board);
  AcquireTWI();
  uint8_t *b = (uint8_t *)&ival;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(b[0]);
  Wire.write(b[1]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();  
}

void SetInt(int board, int cmd, int ival)
{
  SelectBoard(board);
  AcquireTWI();
  uint8_t *b = (uint8_t *)&ival;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(b[0]);
  Wire.write(b[1]);
  Wire.write(b[2]);
  Wire.write(b[3]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();  
}

void SetFloat(int board, int cmd, float fval)
{
  SelectBoard(board);
  AcquireTWI();
  uint8_t *b = (uint8_t *)&fval;
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(b[0]);
  Wire.write(b[1]);
  Wire.write(b[2]);
  Wire.write(b[3]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();  
}

void SetARBcommonClock(ARBdata *ad, int freq)
{
  int clkdiv;
  int actualF;

  if(ad == NULL) return;
  ARBclock->stop();
  if(strcmp(ad->Mode,"TWAVE") == 0)
  {
    clkdiv = VARIANT_MCK / (2 * ad->PPP * freq) + 1;
    actualF = VARIANT_MCK / (2 * ad->PPP * clkdiv);
    ARBclock->setFrequency(actualF * ad->PPP);
  }
  else
  {
    clkdiv = VARIANT_MCK / (2 * freq) + 1;
    actualF = VARIANT_MCK / (2 * clkdiv);
    ARBclock->setFrequency(actualF);
  }
  ARBclock->setTIOAeffect(clkdiv - 2, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET);
  ARBclock->start(-1, 0, true);
}

void SetFrequency(int board, int freq)
{
  uint8_t *b;

  SelectBoard(board);
  b = (uint8_t *)&freq;
  // Send the frequency to the ARB module
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_FREQ);
  Wire.write(b[0]);
  Wire.write(b[1]);
  Wire.write(b[2]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetAmplitude(int board, float Voltage)
{
  uint8_t *b;
  
  SelectBoard(board);
  // Amplitude is 0 to 100Vp-p for 0 to 4095 ref level on the ARB
  int i = Voltage * 32.8;
  if (i > 4095) i = 4095;
  if (i < 0) i = 0;
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_REF);
  Wire.write(i & 0xFF);
  Wire.write((i >> 8) & 0xFF);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();

  SetFloat(board, TWI_SET_RANGE, Voltage);
}

// This command support the dual output amplifier board option. Each board
// can have a seperate offset. Add = 0 or 1 for board A or B.
void SetBoardBias(int board, int add, float Voltage, uint8_t cmd)
{
  uint8_t *b;

  b = (uint8_t *)&Voltage;
  SelectBoard(board);
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(cmd);
  Wire.write(add);
  Wire.write(b[0]);
  Wire.write(b[1]);
  Wire.write(b[2]);
  Wire.write(b[3]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

// Here after user selects a waveform type, update the data structure.
void SetWaveform(int board, WaveFormTypes wft)
{
  AcquireTWI();
  SelectBoard(board);
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_WAVEFORM);
  switch (wft)
  {
    case ARB_SIN:
      Wire.write(TWI_WAVEFORM_SIN);
      break;
    case ARB_RAMP:
      Wire.write(TWI_WAVEFORM_RAMP);
      break;
    case ARB_TRIANGLE:
      Wire.write(TWI_WAVEFORM_TRI);
      break;
    case ARB_PULSE:
      Wire.write(TWI_WAVEFORM_PULSE);
      break;
    case ARB_ARB:
      Wire.write(TWI_WAVEFORM_ARB);
      break;
    default:
      Wire.write(TWI_WAVEFORM_SIN);
      break;
  }
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

void SetARBwaveform(int board)
{
  int i;
  
  SelectBoard(board);
  // Send to the ARB module
  AcquireTWI();
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_VECTOR);
  Wire.write(0);
  Wire.write(16);
  for (i = 0; i < 16; i++) Wire.write(ARBarray[board]->WaveForm[i]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  Wire.beginTransmission(ARBarray[board]->ARBadr);
  Wire.write(TWI_SET_VECTOR);
  Wire.write(16);
  Wire.write(16);
  for (i = 0; i < 16; i++) Wire.write(ARBarray[board]->WaveForm[i+16]);
  {
    AtomicBlock< Atomic_RestoreState > a_Block;
    Wire.endTransmission();
  }
  ReleaseTWI();
}

// Write the current board parameters to the EEPROM on the ARB board.
void SaveARBsettings(void)
{
  SelectBoard(SelectedARBboard);
  arb.Size = sizeof(ARBdata);
  if (WriteEEPROM(&arb, arb.EEPROMadr, 0, sizeof(ARBdata)) == 0)
  {
    DisplayMessage("Parameters Saved!", 2000);
  }
  else DisplayMessage("Unable to Save!", 2000);
}

void RestorARBsettings(bool NoDisplay)
{
  ARBdata ad;
//  bool SaveEnableFlag;

  SelectBoard(SelectedARBboard);
  if (ReadEEPROM(&ad, ARB->EEPROMadr, 0, sizeof(ARBdata)) == 0)
  {
    if (strcmp(ad.Name, ARB->Name) == 0)
    {
      // Here if the name matches so copy the data to the operating data structure
      if (ad.Size > sizeof(ARBdata)) ad.Size = sizeof(ARBdata);
      ad.EEPROMadr = ARB->EEPROMadr;
      memcpy(ARB, &ad, ad.Size);
      arb = *ARB;
      if (!NoDisplay) DisplayMessage("Parameters Restored!", 2000);
    }
    else if (!NoDisplay) DisplayMessage("Corrupted EEPROM data!", 2000);
  }
  else if (!NoDisplay) DisplayMessage("Unable to Restore!", 2000);
}

void RestorARBsettings(void)
{
  RestorARBsettings(false);
}

// External trigger interrupt vectors here!
void ARBsyncISR(void)
{
   static Pio *pio = g_APinDescription[ARBsync].pPort;
   static uint32_t pin =g_APinDescription[ARBsync].ulPin;

   // digitalWrite(ARBsync,HIGH);
   // digitalWrite(ARBsync,LOW); 
   pio->PIO_SODR = pin;   // Set sync line high
   delayMicroseconds(1);  
   pio->PIO_CODR = pin;   // Set sync line low
}

// This function is called at powerup to initiaize the ARB board(s).
// 
void ARB_init(int8_t Board, int8_t addr)
{
  // If this is the first board then reset all the ARB CPUs
  if (NumberOfARBchannels == 0)
  {
     pinMode(14,OUTPUT);
     digitalWrite(14,LOW);
     delay(10);
     digitalWrite(14,HIGH);
     delay(100);
  }
  // If there are already two or more channels add 2 to the board number
  if(NumberOfARBchannels >= 16) Board += 2;
  // Allocate the module data structure based on board number passed
  ARBarray[Board]  = new ARBdata;
  ARBstates[Board] = new ARBstate;
  // Fill the array with default data
  *ARBarray[Board] = ARB_Rev_1;
  // Init the state array
  strcpy(ARBstates[Board]->Mode,"------");
  ARBstates[Board]->update = true;
  // Set active board to board being inited
  SelectedARBboard = Board;
  SelectBoard(Board);
  ARB->EEPROMadr   = addr;
  ARBsyncIN[Board] = new DIhandler;
  DIdirARB[Board]  = new DIhandler;
  // If normal startup load the EEPROM parameters from the ARB module card.
  if (NormalStartup)
  {
    RestorARBsettings(true);
  }
  ARB->EEPROMadr = addr;
  ARBsyncIN[Board]->detach();
  ARBsyncIN[Board]->attached(ARB->ARBsyncIn, ARB->ARBsyncLevel, ARBsyncISR);
  // Init the hardware here...
  pinMode(ARBsync,OUTPUT);
  digitalWrite(ARBsync,LOW);
  // Read the points per waveform for this ARB channel
  int i;
  if(Read8bitUnsigned(Board,TWI_READ_PPP,&i))
  {
    if((i>=8) && (i<=32)) ARBarray[Board]->PPP = i;
  }
  else ARBarray[Board]->PPP = 32;
  if (NumberOfARBchannels == 0)
  {
    arb = *ARB;
    AddMainMenuEntry(&MEARBmodule);
    SelectARBmodule(false);
    SetModeMenus(false);
    CurrentModule = ARBmodule;
    if (ActiveDialog == NULL) ActiveDialog = &ARBdialog;
    // Configure Threads
    ARBthread.setName("ARB");
    ARBthread.onRun(ARB_loop);
    ARBthread.setInterval(100);
    // Add threads to the controller
    control.add(&ARBthread);
    // Start the common clock in case we need it
    ARBclock = new MIPStimer(TMR_ARBclock);
  }
  else
  {
    // Set back to first board
    if(NumberOfARBchannels == 8) ARBcompressor_init();
    SelectedARBboard = 0;
    SelectBoard(0);
    arb = *ARB;
    SetModeMenus(false);
  }
  // Set the frequency
  //SetFrequency(Board,ARBarray[Board]->Frequency);
  // If we are using a common clock then signal the ARB module to use external clock
  if(ARBarray[Board]->UseCommonClock) SetBool(Board, TWI_SET_EXT_CLOCK, true);
  // Read the arb version and set the global variable, we assume all ARBs are the
  // same version
  if(!ReadFloat(Board,TWI_READ_VERSION,&ARBversion)) ARBversion = 0;
  if(ARBversion > 1.13)
  {
    DialogBoxEntry *de = GetDialogEntries(ARBentriesPage2, "Sweep");
    de->Type = D_PAGE;
    ARBsweepTrigDI[Board] = new DIhandler;
  }
  if(ARBversion > 1.16)
  {
    DialogBoxEntry *de = GetDialogEntries(ARBentriesPage2, "Ramp rate");
    de->Type = D_FLOAT;
  }
  NumberOfARBchannels += 8;  // Always add eight channels for each board
  // Set the maximum number of channels in the selection menu
  ARBentriesPage1[0].Max = NumberOfARBchannels / 8;
  ARBentriesPage1arb[0].Max = NumberOfARBchannels / 8;
}

// This is the ARB processing loop. This function is called by the task controller
void ARB_loop(void)
{
  int    b;
  bool   bstate;
  String WFS;
  static DialogBoxEntry *de = GetDialogEntries(ARBentriesPage1, "Frequency");

  if ((ActiveDialog == &ARBdialog) || (ActiveDialog == &ARBCompressorDialog))
  {
    if(ActiveDialog->Changed)
    {
      *ARB = arb;
      WFS = WFT;
      ARB->wft = GetWaveformType(WFS);  // In case this value changed
      ActiveDialog->Changed = false;
    }
    // If the mode has changed then update the display with the new mode
    arb=*ARB;
    if(CurrentModule != ARBmodule)
    {
      SelectARBmodule();
      CurrentModule = ARBmodule;
    }
  }
  ProcessSweep();
  ARBcompressor_loop();
  // Process each ARB board. Look for changes in parameters and update as needed
  for(b = 0; b < 4; b++)
  {
    if(ARBarray[b] != NULL)
    {
      SelectBoard(b);
      // If mode is Twave make sure frequency is not over the maximum value
      if(strcmp("TWAVE",ARBarray[b]->Mode) == 0)
      {
        if(ARBarray[b]->Frequency > de->Max) ARBarray[b]->Frequency = de->Max;
      }
      if((ARBstates[b]->update) || (strcmp(ARBstates[b]->Mode,ARBarray[b]->Mode) != 0))
      {
        SetMode(b,ARBarray[b]->Mode);
        strcpy(ARBstates[b]->Mode,ARBarray[b]->Mode);
        ARBstates[b]->Enable = -2;
        if(b == SelectedARBboard)
        {
           strcpy(arb.Mode,ARBarray[b]->Mode);
           if(ActiveDialog == &ARBdialog) SetModeMenus(true);
           else SetModeMenus(false);
        }
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Freq != ARBarray[b]->Frequency))
      {
        if(ARBarray[b]->UseCommonClock)
        {
          SetARBcommonClock(ARBarray[b], ARBarray[b]->Frequency);
          // Set all channels with the common clock flag set
          for(int i=0;i<4;i++)
          {
            if(ARBarray[i] != NULL)
            {
              if(ARBarray[i]->UseCommonClock) ARBarray[i]->Frequency = ARBarray[b]->Frequency;
            }
          }
        }
        SetFrequency(b,ARBarray[b]->Frequency);
        ARBstates[b]->Freq = ARBarray[b]->Frequency;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Amplitude != ARBarray[b]->Voltage))
      {
        SetAmplitude(b, ARBarray[b]->Voltage);
        ARBstates[b]->Amplitude = ARBarray[b]->Voltage;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Offset != ARBarray[b]->Offset))
      {
        if (ARBarray[0]->ARBcommonOffset)  // True is using a common offset
        {
          // Set all offset channels channels
          for(int i=0;i<4;i++)
          {
            if(ARBarray[i] != NULL)
            {
              ARBarray[i]->Offset = ARBarray[b]->Offset;
            }
          }
        }
        SetFloat(b, TWI_SET_OFFSETV, ARBarray[b]->Offset);
        ARBstates[b]->Offset = ARBarray[b]->Offset;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Aux != ARBarray[b]->Aux))
      {
        SetFloat(b, TWI_SET_AUX, ARBarray[b]->Aux);
        ARBstates[b]->Aux = ARBarray[b]->Aux;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->RampRate != ARBarray[b]->RampRate))
      {
        SetFloat(b, TWI_SET_RAMP, ARBarray[b]->RampRate);
        ARBstates[b]->RampRate = ARBarray[b]->RampRate;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->BufferLength != ARBarray[b]->BufferLength))
      {
        SetBufferLength(b, ARBarray[b]->BufferLength);
        ARBstates[b]->BufferLength = ARBarray[b]->BufferLength;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->NumBuffers != ARBarray[b]->NumBuffers))
      {
        SetNumBuffers(b, ARBarray[b]->NumBuffers);
        ARBstates[b]->NumBuffers = ARBarray[b]->NumBuffers;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Direction != ARBarray[b]->Direction))
      {
        SetBool(b, TWI_SET_DIR, !ARBarray[b]->Direction);
        ARBstates[b]->Direction = ARBarray[b]->Direction;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->WFT != ARBarray[b]->wft))
      {
        SetWaveform(b, ARBarray[b]->wft);
        ARBstates[b]->WFT = ARBarray[b]->wft;
      }
      if((ARBstates[b]->update) || (ARBstates[b]->Enable != ARBarray[b]->Enable))
      {
        SetBool(b, TWI_SET_ENABLE, ARBarray[b]->Enable);
        ARBstates[b]->Enable = ARBarray[b]->Enable;
      }
      if((ARBstates[b]->update) || (ARBarray[b]->DualOutputs))
      {
        if(ARBstates[b]->OffsetA != ARBarray[b]->OffsetA)
        {
           SetBoardBias(b, 0, ARBarray[b]->OffsetA);
           ARBstates[b]->OffsetA = ARBarray[b]->OffsetA;
        }
        if(ARBstates[b]->OffsetB != ARBarray[b]->OffsetB)
        {
           SetBoardBias(b, 1, ARBarray[b]->OffsetB);
           ARBstates[b]->OffsetB = ARBarray[b]->OffsetB;
        }
      }
      if((ARBstates[b]->update) || (ARBstates[b]->ARBwaveformUpdate))
      {
        SetARBwaveform(b);
        ARBstates[b]->ARBwaveformUpdate = false;
      }
      if ((ARBarray[b]->ARBsyncIn != ARBsyncIN[b]->di) || (ARBarray[b]->ARBsyncLevel != ARBsyncIN[b]->mode) || ARBstates[b]->update)
      {
         ARBsyncIN[b]->detach();
         if((int)ARBarray[b]->ARBsyncIn != 0)
         {
            bstate = ARBsyncIN[b]->attached(ARBarray[b]->ARBsyncIn, ARBarray[b]->ARBsyncLevel, ARBsyncISR);
            SetBool(b, TWI_SET_SYNC_ENA, bstate);
         }
      }
      if ((ARBarray[b]->ARBdirDI != DIdirARB[b]->di) || (ARBarray[b]->ARBdirLevel != DIdirARB[b]->mode) || ARBstates[b]->update)
      {
         DIdirARB[b]->detach();
         DIdirARB[b]->attached(ARBarray[b]->ARBdirDI, ARBarray[b]->ARBdirLevel, ARBdirISRs[b]);
      }
      // Process sweep parameters only for version 1.14 and greater
      if(ARBversion > 1.13)
      {
        if((ARBstates[b]->StartFreq != ARBarray[b]->StartFreq) || ARBstates[b]->update)
        {
           SetInt(b, TWI_SWPSTARTFREQ, ARBarray[b]->StartFreq);
           ARBstates[b]->StartFreq = ARBarray[b]->StartFreq;
        }
        if((ARBstates[b]->StopFreq != ARBarray[b]->StopFreq) || ARBstates[b]->update)
        {
           SetInt(b, TWI_SWPSTOPFREQ, ARBarray[b]->StopFreq);
           ARBstates[b]->StopFreq = ARBarray[b]->StopFreq;
        }
        if((ARBstates[b]->StartVoltage != ARBarray[b]->StartVoltage) || ARBstates[b]->update)
        {
           SetFloat(b, TWI_SWPSTARTV, ARBarray[b]->StartVoltage);
           ARBstates[b]->StartVoltage = ARBarray[b]->StartVoltage;
        }
        if((ARBstates[b]->StopVoltage != ARBarray[b]->StopVoltage) || ARBstates[b]->update)
        {
           SetFloat(b, TWI_SWPSTOPV, ARBarray[b]->StopVoltage);
           ARBstates[b]->StopVoltage = ARBarray[b]->StopVoltage;
        }
        if((ARBstates[b]->SweepTime != ARBarray[b]->SweepTime) || ARBstates[b]->update)
        {
           SetFloat(b, TWI_SWPTIME, ARBarray[b]->SweepTime);
           ARBstates[b]->SweepTime = ARBarray[b]->SweepTime;
        }
        // process the sweep trigger options
        if ((ARBarray[b]->ARBsweepTrig != ARBsweepTrigDI[b]->di) || (ARBarray[b]->ARBsweepLevel != ARBsweepTrigDI[b]->mode) || ARBstates[b]->update)
        {
           ARBsweepTrigDI[b]->detach();
           ARBsweepTrigDI[b]->attached(ARBarray[b]->ARBsweepTrig, ARBarray[b]->ARBsweepLevel, ARBsweepISRs[b]);
        }
      }
    }
    ARBstates[b]->update = false;
  }
  SelectBoard(SelectedARBboard);
  if (ActiveDialog->Entry == ARBentriesPage1) RefreshAllDialogEntries(&ARBdialog);
  if (ActiveDialog->Entry == ARBentriesPage1arb) RefreshAllDialogEntries(&ARBdialog);
  if (ActiveDialog->Entry == ARBentriesPage2) RefreshAllDialogEntries(&ARBdialog);
  if (ActiveDialog->Entry == ARBwaveformEdit) RefreshAllDialogEntries(&ARBdialog);
  arb = *ARB;
}

//
// ARB Twave serial host commands
//

// Returns the number of ARB channels
void ReportARBchannels(void)
{
  SendACKonly;
  if (!SerialMute) serial->println(NumberOfARBchannels);
}

bool IsARBmodule(int index)
{
  if((index < 0) || (index > 3))
  {
    SetErrorCode(ERR_BADARG);
    SendNAK;
    return false;    
  }
  if(ARBarray[index] == NULL)
  {
    SetErrorCode(ERR_NOARB);
    SendNAK;
    return false;
  }
  return true;
}

// This function converts the ARB module number (1 thru 4) into the board index.
// The board index is returned, -1 if invalud. If the report flag is
// true this function will send NAK to host.
int ARBmoduleToBoard(int Module, bool report)
{
  int b=-1;

  if(Module == 1)
  {
    if(ARBarray[0] != NULL) b = 0;
    if((ARBarray[0] == NULL) && (ARBarray[1] != NULL)) b = 1;
  }
  if((Module == 2) && (ARBarray[0] != NULL) && (ARBarray[1] != NULL)) b = 1;
  if((Module == 3) && (ARBarray[2] != NULL)) b = 2;
  if((Module == 4) && (ARBarray[3] != NULL)) b = 3;
  if(b != -1) return(b);
  if(report)
  {
    SetErrorCode(ERR_BADCMD);
    SendNAK;
  }
  return(b);
}

// Sets the TWI address, radix 10
void SetARBtwiADD(int module, int add)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  ARBarray[b]->ARBadr = add;
  SendACK;  
}

// Returns the TWI address, radix 10
void GetARBtwiADD(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;  
  if(!SerialMute) serial->println(ARBarray[b]->ARBadr);
}

void SetARBUseCommonClock(char *module, char *flag)
{
  String smode;
  int b,mod;

  smode = module;
  mod = smode.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  smode = flag;
  if((smode == String("TRUE")) || (smode == String("FALSE")))
  {
     ARBstates[b]->Freq = 0;
     if(smode == String("TRUE")) 
     {
        ARBarray[b]->UseCommonClock = true;
        SetBool(b, TWI_SET_EXT_CLOCK, true);
     }
     else  
     {
        ARBarray[b]->UseCommonClock = false;
        SetBool(b, TWI_SET_EXT_CLOCK, false);
     }
     SendACK;
     return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;   
}

void SetARBcommonOffset(char *flag)
{
  String smode;

  smode = flag;
  if((smode == String("TRUE")) || (smode == String("FALSE")))
  {
     if(smode == String("TRUE")) ARBarray[0]->ARBcommonOffset = true;
     else  ARBarray[0]->ARBcommonOffset = false;
     SendACK;
     return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;     
}

void SetARBbufferLength(int module, int len)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  ARBarray[b]->BufferLength = len;
  SetBufferLength(b, len);
  SendACK;
}

void GetARBbufferLength(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->BufferLength);
}

void SetARBbufferNum(int module, int num)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  ARBarray[b]->NumBuffers = num;
  SetNumBuffers(b, num);
  SendACK;
}

void GetARBbufferNum(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->NumBuffers);
}

void SetARBMode(char *module, char *mode)
{
  String smode;
  int b,mod;

  smode = module;
  mod = smode.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  smode = mode;
  if((smode == String("TWAVE")) || (smode == String("ARB")))
  {
    strcpy(ARBarray[b]->Mode,mode);
    SetMode(b, mode);
    SendACK;
    return;
  } 
   SetErrorCode(ERR_BADARG);
   SendNAK;   
}

void GetARBMode(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->Mode);
}


void SetWFfreq(int module, int freq)
{
   int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   float MaxARBfreq = MAXARBRATE / ARBarray[b]->PPP;
   if(((strcmp(ARBarray[b]->Mode,"TWAVE") == 0) && (freq >= 1000) && (freq <= MaxARBfreq)) || ((strcmp(ARBarray[b]->Mode,"ARB") == 0) && (freq >= 1000) && (freq <= 1500000)))
   {
      ARBarray[b]->Frequency = freq;
      SetFrequency(b,freq);
      SendACK;
      return;
   }
   SetErrorCode(ERR_BADARG);
   SendNAK;   
}

void GetWFfreq(int module)
{
   int clkdiv;
   int actualF;
   int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   SendACKonly;
   if(strcmp(ARBarray[b]->Mode,"TWAVE") == 0)
   {
     clkdiv = VARIANT_MCK / (2 * ARBarray[b]->PPP * ARBarray[b]->Frequency) + 1;
     actualF = VARIANT_MCK / (2 * ARBarray[b]->PPP * clkdiv);
   }
   else
   {
     clkdiv = VARIANT_MCK / (2 * ARBarray[b]->Frequency) + 1;
     actualF = VARIANT_MCK / (2 * clkdiv);
   }
   if (!SerialMute) serial->println(actualF);
}

void SetWFdisable(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACK;
  ARBarray[b]->Enable = false;
  SetBool(b,TWI_SET_ENABLE,false);
}

void SetWFenable(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACK;
  ARBarray[b]->Enable = true;
  SetBool(b,TWI_SET_ENABLE,true);
}

// This function sets the ARB DAC voltage range
void SetWFrange(char *module, char *srange)
{
  float  range;
  String spar,smod;
  int b,mod;

  smod = module;
  mod = smod.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  spar = srange;
  range = spar.toFloat();
  if((range >= 0) && (range <= 100))
  {
    ARBarray[b]->Voltage = range;
    SetAmplitude(b, range);
    SendACK;
    return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;
}

void GetWFrange(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->Voltage);
}

void SetWFoffsetV(char *module, char *srange)
{
  float  range;
  String spar, smod;
  int b, mod;

  smod = module;
  mod = smod.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  spar = srange;
  range = spar.toFloat();
  if((range >= -50) && (range <= 50))
  {
    ARBarray[b]->Offset = range;
    SetFloat(b, TWI_SET_OFFSETV, range);
    SendACK;
    return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;
}

void GetWFoffsetV(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->Offset);  
}

void SetWFaux(char *module, char *srange)
{
  float  range;
  String spar, smod;
  int b,mod;

  smod = module;
  mod = smod.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  spar = srange;
  range = spar.toFloat();
  if((range >= -50) && (range <= 50))
  {
    ARBarray[b]->Aux = range;
    SetFloat(b, TWI_SET_AUX, range);
    SendACK;
    return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;
}

void GetWFaux(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->Aux);  
}

void SetWFramp(char *module, char *sramp)
{
  float  ramp;
  String spar, smod;
  int b,mod;

  smod = module;
  mod = smod.toInt();
  if((b = ARBmoduleToBoard(mod,true)) == -1) return;
  spar = sramp;
  ramp = spar.toFloat();
  if((ramp >= 0) && (ramp <= 10000))
  {
    ARBarray[b]->RampRate = ramp;
    SendACK;
    return;
  }
  SetErrorCode(ERR_BADARG);
  SendNAK;
}

void GetWFramp(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(ARBarray[b]->RampRate);  
}

void SetARBdirection(char *module, char *dir)
{
   String sToken;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   if(strcmp(dir,"FWD") == 0)
   {
     ARBarray[b]->Direction = true;
     SendACK;
     return;
   }
   if(strcmp(dir,"REV") == 0)
   {
     ARBarray[b]->Direction = false;
     SendACK;
     return;
   }
   SetErrorCode(ERR_BADARG);
   SendNAK;
}

void GetARBdirection(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if (ARBarray[b]->Direction)
  {
    if (!SerialMute) serial->println("FWD");
  }
  else if (!SerialMute) serial->println("REV");  
}

void SetARBwfType(char *sMod, char *Swft)
{
   String sToken;
   int    b,mod;

   sToken = sMod;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   if(strcmp(Swft,"SIN") == 0)        ARBarray[b]->wft = ARB_SIN;
   else if(strcmp(Swft,"RAMP") == 0)  ARBarray[b]->wft = ARB_RAMP;
   else if(strcmp(Swft,"TRI") == 0)   ARBarray[b]->wft = ARB_TRIANGLE;
   else if(strcmp(Swft,"PULSE") == 0) ARBarray[b]->wft = ARB_PULSE;
   else if(strcmp(Swft,"ARB") == 0)   ARBarray[b]->wft = ARB_ARB;
   else
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   if(SelectedARBboard == b) strcpy(WFT,Swft);
   SendACK;
}

void GetARBwfType(int module)
{
  int b;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(!SerialMute) serial->println(GetWaveformString(ARBarray[b]->wft));
}

// This function defines an arbitrary waveform. This function pulls
// all the arguments from the input ring buffer
// Module,val1,val2...
void SetARBwaveform(void)
{
   char   *Token;
   String sToken;
   int    i,mod,b;
   float  vals[ppp];

   while(1)
   {
     // Read all the arguments
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     mod = sToken.toInt();
     
     i = 0;
     while(true)
     {
        GetToken(true);
        if((Token = GetToken(true)) == NULL) break;
        sToken = Token;
        if(Token[0] == '\n') break;
        if(i<(ppp)) vals[i] = sToken.toFloat();
        i++;
     }
//   if(Token == NULL) break;
     // Test arguments
     if((b = ARBmoduleToBoard(mod,true)) == -1) return;
     if(i != ARBarray[b]->PPP)
     {
       SetErrorCode(ERR_BADARG);
       SendNAK;
       return;      
     }
     for(i=0;i<ARBarray[b]->PPP;i++) if((vals[i] < -100) || (vals[i] > 100))
     {
       SetErrorCode(ERR_BADARG);
       SendNAK;
       return;
     }
     // Fill the waveform buffer and set flag to send waveform
     for(i=0;i<ARBarray[b]->PPP;i++) ARBarray[b]->WaveForm[i] = vals[i];
     ARBstates[b]->ARBwaveformUpdate = true;
     // If the user interface is displaying this channel then update the display array
     if((ActiveDialog->Entry == ARBwaveformEdit) && (SelectedARBboard == b))
     {
        for (i = 0; i < ARBarray[b]->PPP; i++) ARBwaveform[i] = vals[i];
     }
     SendACK;
   }
}

// Reports the ARB waveform
void GetARBwaveform(int module)
{
  int b,i;

  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(SerialMute) return;
  for(i=0;i<ARBarray[b]->PPP;i++)
  {
    serial->print(ARBarray[b]->WaveForm[i]);
    if(i == (ARBarray[b]->PPP-1)) serial->println("");
    else serial->print(","); 
  }
  SendACK;
}

void SetARBchns(char *module, char *sval)
{
   String sToken;
   float  val;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   sToken = sval;
   val = sToken.toFloat();
   if((val < -100) || (val > 100))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   SetFloat(b, TWI_SET_SET_BUFFER, val);
   SendACK;
}

void SetARBDualBoard(char *module, char *sval)
{
   String sToken;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   sToken = sval;
   if((sToken != "TRUE") && (sToken != "FALSE"))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   if(sToken == "TRUE") ARBarray[b]->DualOutputs = true;
   else  ARBarray[b]->DualOutputs = false;
   SendACK;
}

// This command will set an ARB channel to a defined value over its full range.
// All parameters are pulled from the ring buffer.
//  Module,Channel,value
//  Module is 1 or 2
//  Channel is 1 through 8
void SetARBchannel(void)
{
   char   *Token;
   String sToken;
   int    ch,mod,b;
   float  val;

   while(1)
   {
     // Read all the arguments
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     mod = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     ch = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     val = sToken.toFloat();
     if((Token = GetToken(true)) == NULL) break;
     if(Token[0] != '\n') break;
     // Test the range arguments
     if((ch < 1) || (ch > 8)) break;
     if((val < -100) || (val > 100)) break;
     if((b = ARBmoduleToBoard(mod,true)) == -1) return;
     SetChannelRangeMessage(b,ch,0,ARBarray[b]->BufferLength,val);
     SendACK;
     return;
   }
   SetErrorCode(ERR_BADARG);
   SendNAK;  
}

// This command will set an ARB channel to a defined value over a defined range.
// All parameters are pulled from the ring buffer.
//  Module,Channel,Start index,Stop index,value
void SetARBchanRange(void)
{
   char   *Token;
   String sToken;
   int    ch,b,StartI,StopI,mod;
   float  val;

   while(1)
   {
     // Read all the arguments
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     mod = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     ch = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     StartI = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     StopI = sToken.toInt();
     GetToken(true);
     if((Token = GetToken(true)) == NULL) break;
     sToken = Token;
     val = sToken.toFloat();
     if((Token = GetToken(true)) == NULL) break;
     if(Token[0] != '\n') break;
     // Test the range
     if((b = ARBmoduleToBoard(mod,true)) == -1) return;
     if((ch < 1) || (ch > 8)) break;
     if((StartI < 1) || (StartI >= ARBarray[b]->BufferLength)) break;
     if((StopI < 1) || (StopI >= ARBarray[b]->BufferLength)) break;
     if(StartI > StopI) break;
     if((val < -100) || (val > 100)) break;
     // Now we can call the function!
     SendACK;
     SetChannelRangeMessage(b,ch,StartI,StopI,val);
     return;
   }
   // If here then we had bad arguments!
  SetErrorCode(ERR_BADARG);
  SendNAK;
}

// The following functions support the dual output board option avalible on rev 3.0
// arb modules. this option allows independent offsets on each board.
void SetARBoffsetBoardA(char *module, char *val)
{
   String sToken;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   sToken = val;
   if(!ARBarray[b]->DualOutputs)
   {
     SetErrorCode(ERR_NOTSUPPORTED);
     SendNAK;
     return;    
   }
   if((sToken.toFloat() < -10.0) || (sToken.toFloat() > 10.0))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   ARBarray[b]->OffsetA = sToken.toFloat();
   SendACK;
}

void GetARBoffsetBoardA(int module)
{
  int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   if(!ARBarray[b]->DualOutputs)
   {
     SetErrorCode(ERR_NOTSUPPORTED);
     SendNAK;
     return;    
   }
   SendACKonly;
   if(!SerialMute) serial->println(ARBarray[b]->OffsetA);
}

void SetARBoffsetBoardB(char *module, char *val)
{
   String sToken;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   sToken = val;
   if(!ARBarray[b]->DualOutputs)
   {
     SetErrorCode(ERR_NOTSUPPORTED);
     SendNAK;
     return;    
   }
   if((sToken.toFloat() < -10.0) || (sToken.toFloat() > 10.0))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   ARBarray[b]->OffsetB = sToken.toFloat();
   SendACK;  
}

void GetARBoffsetBoardB(int module)
{
  int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   if(!ARBarray[b]->DualOutputs)
   {
     SetErrorCode(ERR_NOTSUPPORTED);
     SendNAK;
     return;    
   }
   SendACKonly;
   if(!SerialMute) serial->println(ARBarray[b]->OffsetB);  
}

void ARBmoduleSync(void)
{
  ARBsyncISR();
}

// The following functions are used by the pulse sequence generator (table mode) to send commands
// to the ARB modules. The following commands are supported:
// Aux (boards 0 thru 3)
// OffsetA (boards 0 and 1)
// OffsetB (boards 0 and 1)
//  101 = aux channel 1
//  102 = aux channel 2
//  103 = aux channel 3
//  104 = aux channel 4
//  105 = offset channel 1a
//  106 = offset channel 1b
//  107 = offset channel 2a
//  108 = offset channel 2b
// The ARB uses a TWI interface and this same interfrace is extensively used in the MIPS apps via
// most modules. A TWI acquire and release system is used to insure exclusive use of the TWI interface,
// if the interface is busy then the actions are queued to run as soon as the blocking function releases 
// the interface. This logic greatly complicate the ARB table functions shown below.

// Bit flag:
// 0 set if ARB brd 0 needs update
// 1 set if ARB brd 0 needs update
// 2 set if ARB brd 0 needs update
// 3 set if ARB brd 0 needs update
int8_t ARBupdatesSent = 0;

void UpdateAux(int8_t brd, float val, bool FlushQueued)
{
  static float vals[4];
  static bool  Queued[4] = {false,false,false,false};


  if(FlushQueued)
  {
    // If here assume the TWI interface is avalible so send any queued data
    int b=SelectedBoard();
    for(int i=0; i<4; i++) 
    {
      if(Queued[i])
      {
         SetFloat(i, TWI_UPDATE_AUX, vals[i]);     
         ARBupdatesSent |= 1 << i;
      }
    }
    SelectBoard(b); 
    Queued[0] = Queued[1] = Queued[2] = Queued[3] = false;
    return;
  }
  if((brd < 0) || (brd > 3)) return;
  // Acquire the TWI interface
  if(AcquireTWI())
  {
    // Here if TWI interface is avalible
    int b=SelectedBoard();
    SetFloat(brd, TWI_UPDATE_AUX, val);
    SelectBoard(b);           
    ARBupdatesSent |= 1 << brd;
  }
  else
  {
    // If here TWI is in use so queue up this request
    vals[brd] = val;
    Queued[brd] = true;
    QueueARBupdate();
  } 
}

void UpdateOffsetA(int8_t brd, float val, bool FlushQueued)
{
  static float vals[2];
  static bool  Queued[2] = {false,false};

  if(FlushQueued)
  {
    // If here assume the TWI interface is avalible so send any queued data
    int b=SelectedBoard();
    for(int i=0; i<2; i++) 
    {
      if(Queued[i])
      {
         SetBoardBias(i, 0, vals[i], TWI_UPDATE_BRD_BIAS); 
         ARBupdatesSent = 1 << i;        
      }
    }
    SelectBoard(b); 
    Queued[0] = Queued[1] = false;
    return;
  }
  if((brd < 0) || (brd > 1)) return;
  // Acquire the TWI interface
  if(AcquireTWI())
  {
    // Here if TWI interface is avalible
    int b=SelectedBoard();
    SetBoardBias(brd, 0, val, TWI_UPDATE_BRD_BIAS);    
    SelectBoard(b);           
    ARBupdatesSent |= 1 << brd;
  }
  else
  {
    // If here TWI is in use so queue up this request
    vals[brd] = val;
    Queued[brd] = true;
    QueueARBupdate();
  }
}

void UpdateOffsetB(int8_t brd, float val, bool FlushQueued)
{
  static float vals[2];
  static bool  Queued[2] = {false,false};

  if(FlushQueued)
  {
    // If here assume the TWI interface is avalible so send any queued data
    int b=SelectedBoard();
    for(int i=0; i<2; i++) 
    {
      if(Queued[i])
      {
        SetBoardBias(i, 1, vals[i], TWI_UPDATE_BRD_BIAS); 
        ARBupdatesSent = 1 << i;
      }
    }
    SelectBoard(b); 
    Queued[0] = Queued[1] = false;
    return;
  }
  if((brd < 0) || (brd > 1)) return;
  // Acquire the TWI interface
  if(AcquireTWI())
  {
    // Here if TWI interface is avalible
    int b=SelectedBoard();
    SetBoardBias(brd, 1, val, TWI_UPDATE_BRD_BIAS);    
    SelectBoard(b);           
    ARBupdatesSent |= 1 << brd;
  }
  else
  {
    // If here TWI is in use so queue up this request
    vals[brd] = val;
    Queued[brd] = true;
    QueueARBupdate();
  }
}

void ProcessQueuedARB(void)
{
  UpdateAux(0,0,true);
  UpdateOffsetA(0,0,true);
  UpdateOffsetB(0,0,true);
  QueueARBupdate(true);
}

void QueueARBupdate(bool Release)
{
  static bool Queued = false;

  if(Release)
  {
    Queued = false;
    return;
  }
  if(Queued) return;
  Queued = true;
  TWIqueue(ProcessQueuedARB);
}

// Called at LDAC generation time, send the update command if updates have happened
void ProcessARB(void)
{
  if(ARBupdatesSent == 0) return;
  // If the TWI is not avalible then queue this function to
  // execute when it is free
  if(!AcquireTWI())
  {
    TWIqueue(ProcessARB);
    return;
  }
  // Send the update command to each ARB board that has updates pending
  for(int i=0; i<4; i++)
  {
      if(ARBupdatesSent & (1 << i))
      {
         // Save current board select and then select the board
         int b=SelectedBoard();
         SelectBoard(i);
         Wire.beginTransmission(ARBarray[i]->ARBadr);
         Wire.write(TWI_LOAD_UPDATES);
         {
            AtomicBlock< Atomic_RestoreState > a_Block;
            Wire.endTransmission();
         } 
         // Restore the board select
         SelectBoard(b);
      }
  }   
  ARBupdatesSent = 0;
  ReleaseTWI();
}

// This function saves the ARB module data to EEPROM. All detected ARB modules are saved.
void SaveARB2EEPROM(void)
{
  int  brd;
  bool berr = false;
  
  brd = SelectedBoard();
  for(int b=0; b<4; b++)
  {
    if(ARBarray[b] != NULL)
    {
      SelectBoard(b);
      if (WriteEEPROM(ARBarray[b], ARBarray[b]->EEPROMadr, 0, sizeof(ARBdata)) != 0) berr = true;
    }
  }
  SelectBoard(brd);
  if(berr)
  {
    SetErrorCode(ERR_EEPROMWRITE);
    SendNAK;
    return;
  }
  SendACK;
}

void GetARBversion(int module)
{
  int b;

   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   SendACKonly;
   if(SerialMute) return;
   // Read version float from ARB
   float fVer;
   if(ReadFloat(b,TWI_READ_VERSION,&fVer))
   {
      serial->print("ARB version: ");
      serial->println(fVer);
      return;
   }
   serial->println("ARB version is prior to 1.14");  
}

// Returns the points per waveform
void GetARBppp(int module)
{
  int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   SendACKonly;
   if(SerialMute) return;
   serial->println(ARBarray[b]->PPP);
}

// This function sets the points per waveform in the selected ARB module.
// This function will save the updates in the ARB module and reboot the MIPS system.
// This is a setup command.
void SetARBppp(int module, int PPP)
{
   int b;
  
   if((b = ARBmoduleToBoard(module,true)) == -1) return;
   // Validate PPP
   if((PPP < 8) || (PPP >32))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;    
   }
   SendACK;
   // Set the PPP on the ARB module
   SetByte(b, TWI_SET_PPP, PPP);
   // Save changes on the ARB module
   Wire.beginTransmission(ARBarray[b]->ARBadr);
   Wire.write(TWI_SAVE);
   Wire.endTransmission();
   // Delay and warn
   serial->println("The MIPS system will reboot soon...");
   delay(1000);
   // Reboot MIPS
   Software_Reset();
}

// Set the external clock source, MIPS or EXT
void SetARBext(char *module, char *val)
{
   String sToken;
   int    b,mod;

   sToken = module;
   mod = sToken.toInt();
   if((b = ARBmoduleToBoard(mod,true)) == -1) return;
   sToken = val;
   if((sToken != "MIPS") && (sToken != "EXT"))
   {
     SetErrorCode(ERR_BADARG);
     SendNAK;
     return;
   }
   if(sToken == "MIPS") SetByte(b, TWI_SET_SEXTSRC, 0);
   else SetByte(b, TWI_SET_SEXTSRC, 1);
   SendACK;    
}

// Sweep start, stop and status commands
void ARBstartSweep(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  // Send TWI command to start a sweep
  SetByte(b, TWI_SWPGO, SS_START);
  SendACK;
}

void ARBstopSweep(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  // Send TWI command to stop a sweep
  SetByte(b, TWI_SWPGO, SS_STOP);
  SendACK;  
}

void GetARBsweepStatus(int module)
{
  int b;
  
  if((b = ARBmoduleToBoard(module,true)) == -1) return;
  SendACKonly;
  if(SerialMute) return;
  // Send read status from ARB module.
  int i;
  if(!Read8bitUnsigned(b,TWI_READ_SWEEP_STATUS, &i)) return;
  switch (i)
  {
    case SS_IDLE:
      serial->println("IDLE"); 
      break;
    case SS_START:
      serial->println("STARTING"); 
      break;
    case SS_STOP:
      serial->println("STOPPING"); 
      break;
    case SS_SWEEPING:
      serial->println("SWEEPING"); 
      break;
    default:
      serial->println("Invalid response from ARB"); 
      break;
  }
}
